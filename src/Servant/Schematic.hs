{-# OPTIONS_GHC -fprint-explicit-kinds #-}

{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

module Servant.Schematic where

import           Control.Monad.IO.Class
import           Data.Aeson
import           Data.Kind
import           Data.Maybe
import           Data.Monoid
import           Data.Proxy
import           Data.Schematic
import           Data.Schematic.JsonSchema
import           Data.Singletons
import           Data.Text
import           GHC.TypeLits
import qualified JSONSchema.Draft4.Schema as D4
import           Servant hiding (Tagged)
import           Servant.API.TypeLevel


data Tagged (t :: k) a = Tagged a deriving (Functor, Show)

instance ToJSON a => ToJSON (Tagged t a) where
  toJSON (Tagged a) = toJSON a

-- type family Expand (req :: Maybe q) (api :: k) :: l where
--   Expand 'Nothing api = api
--   Expand ('Just req) api = req :<|> api

-- class HasSchema (req :: Maybe q) api where
--   type Schematized' req api :: k

-- instance (HasSchema req a, HasSchema req b) => HasSchema req (a :<|> b) where
--   type Schematized' req (a :<|> b) = Schematized req a :<|> Schematized req b

-- instance {-# OVERLAPS #-} HasSchema req (Verb method code ctypes (JsonRepr schema)) where
--   type Schematized' req (Verb method code ctypes (JsonRepr schema)) =
--     Expand req
--       ("response" :> Get '[JSON] (Tagged schema D4.Schema) :<|>
--       Verb method code ctypes (JsonRepr schema))

-- instance {-# OVERLAPPABLE #-} HasSchema req (Verb method code ctypes a) where
--   type Schematized' req (Verb method code ctypes a) =
--     Expand req (Verb method code ctypes a)

-- instance {-# OVERLAPS #-} (HasSchema req sub) => HasSchema req (ReqBody cs (JsonRepr schema) :> sub) where
--   type Schematized' req (ReqBody cs (JsonRepr schema) :> sub) =
--     Schematized' ('Just ("request" :> Get '[JSON] (Tagged schema D4.Schema))) sub

-- instance {-# OVERLAPPABLE #-} (HasSchema req sub) => HasSchema req (ReqBody cs a :> sub) where
--   type Schematized' req (ReqBody cs a :> sub) =
--     Schematized' 'Nothing sub

type family Schematized' (req :: Maybe q) (api :: k) :: k where
  Schematized' 'Nothing (Verb method code ctypes (JsonRepr schema)) =
    "response" :> Get '[JSON] (Tagged schema D4.Schema) :<|>
    Verb method code ctypes (JsonRepr schema)
  Schematized' ('Just req) (Verb method code ctypes (JsonRepr schema)) =
    req :<|>
    "response" :> Get '[JSON] (Tagged schema D4.Schema) :<|>
    Verb method code ctypes (JsonRepr schema)
  Schematized' 'Nothing (Verb method code ctypes a) = Verb method code ctypes a
  Schematized' ('Just req) (Verb method code ctypes a) =
    req :<|> Verb method code ctypes a
  Schematized' req (ReqBody cs (JsonRepr schema) :> sub) =
    Schematized'
      ('Just ("request" :> Get '[JSON] (Tagged schema D4.Schema))) sub
  Schematized' req (ReqBody cs a :> sub) = ReqBody cs a :> Schematized' req sub
  Schematized' req (a :<|> b) = Schematized' req a :<|> Schematized' req b
  Schematized' req (a :> sub) = a :> Schematized' req sub

type family Schematized (api :: k) :: k where
  Schematized api = Schematized' 'Nothing api

-- | An implementation for json-schema introspection handlers generated by
-- @Schematized@ type family. It works with requests and response schemas.
schemaHandler
  :: forall m tag (schema :: Schema) a
   . (SingI schema, Monad m)
  => m (Tagged schema D4.Schema)
schemaHandler = pure . Tagged . fromJust $ toJsonSchema (Proxy @schema)
